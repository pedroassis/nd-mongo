{
  "name": "node-dependency",
  "version": "2.0.8",
  "description": "Dependency Injection for NodeJS, no more require() calls",
  "main": "index.js",
  "keywords": [
    "dependencies",
    "DI",
    "container",
    "angularjs",
    "injection",
    "autowire",
    "dependency"
  ],
  "devDependencies": {
    "mocha": "^1.21.5",
    "sinon": "*",
    "chai": "^1.9.2"
  },
  "author": {
    "name": "pedroassis"
  },
  "license": "ISC",
  "dependencies": {
    "js-annotation-reader": "git://github.com/pedroassis/js-annotation-reader",
    "hashmap": "^2.0.3",
    "ng-di": "0.1.0"
  },
  "scripts": {
    "test": "mocha $(find tests -name '*Test.js') ./tests",
    "cover": "istanbul cover node_modules/.bin/_mocha  $(find tests -name '*Test.js') ./tests & open coverage/lcov-report/index.html"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/pedroassis/node-dependency/tree/v2"
  },
  "readme": "node-dependency - Node Dependency Injection (Beta)\n===============\n\nAutowiring dependencies to you JS files. Without hard-to-write configuration files.  \nYou can cnfigure your files using annotations, yes annotatons. See [JS Annotations](https://github.com/pedroassis/js-annotation-reader).  \nYou can also 'import' and declare 'package' inside your files to handle naming collisions.\n\nnode-dependency has support for plugins too, for instance [node-dependency ExpressJS](https://github.com/pedroassis/nd-express-plugin), this plugin allows you to write RESTFul services inspired by JAX-RS from Java.\n\n[Click here](https://github.com/pedroassis/node-dependency/tree/v2/examples) and browse our example folder to see how an app using node-dependency looks like.\n\n## Installation\n\n```bash\n$ npm install node-dependency\n```\n\n**Never call 'require' again**.\nWell, you still have to call it once:\n\n## Setup\n\n**index.js**\n\n    var statupMethod = require('node-dependency');\n    \n    // You have to specify where your source folder is.\n    statupMethod(__dirname);\n\nThis should be your index.js, and yes no other calls needed.\n\n## Startup class\n\nYou also need a file called **ProjectBootstrap.js** inside your source folder.\n\nNote that if you have a plugin that bootstraps the project, like [node-dependency ExpressJS](https://github.com/pedroassis/nd-express-plugin), you won't need this file.\n\nThis file is where you should start your application, and it should look like this:\n\n```js    \n    // Note that you can get express from the contructor of your class,\n    // no need to 'require' it, but you need to declare it in your package.json\n    function ProjectBootstrap(express){\n        var app = express()\n\n        app.get('/', function (req, res) {\n            res.send('Hello World!')\n        })\n\n        var server = app.listen(3000, function () {\n\n        })\n    }\n    // Is required to export the function\n    module.exports = ProjectBootstrap;\n```\n\nNote that you have to inject your own dependencies on ProjectBootstrap in order to start you app, node-dependency instantiates in lazy mode always.\n\n\nThat means if you don't inject anything on ProjectBootstrap node-dependency won't instantiate any other class.\n\n## Package Scan\n\nnode-dependency will read your package.json and make every dependency declared in there available to inject, and it will read your source folder and declare all the JS and JSON files it can find too.\n\n## Configuration\n\nThere's a configuration file, we need it because most libraries, like this one, have invalid names to declare as a variable name.\n\nThe container will try to **rename** your dependencies as it can.\n\ne.g: 'request-promise' will be available as requestPromise.\n\nWe remove the dash '-' and declare the dependency with a camel-case name.\n\nBut in your **package.json** you can have this configuration:\n\n**package.json**\n\n    {\n        ...\n        \"node-dependency\" : {\n            \"names\" : {\n                \"request-promise\"  : \"request\",\n                \"ng-di\"            : \"ngDI\",\n                \"cheerio\"          : \"$\",\n                \"q\"                : \"Q\",\n                \"sails-mongo\"      : \"sailsMongo\",\n                \"waterline\"        : \"Waterline\",\n                \"fs\"               : \"fileSystem\"\n            }\n        }\n        ...\n    }\n\nThis will assign a different name for your dependencies, not only to make them valid, but also to make them better.\n\nYou see that I depend upon the module 'q' but I want to inject it as 'Q'.\n\nNote that we added 'request-promise' and rename it to 'request', therefore it won't need to be renamed by the container.\n\nYou also have to declare node internal dependencies like fs.\n\nAside from this file you don't need to explicitly declare or inject anything, every JS file will be loaded and also have its dependencies autowired for you.\n\nsee\n```js\n    \"package sidewalk\" // The package is only a declaration, does not have to be inside a folder named sidewalk\n    // Named function means it is a Class\n    function SideWalk(Q, request, WaterLine){\n        Person.walk();\n    }\n    module.exports = SideWalk;\n```  \n\nThis module is a dependency manager for NodeJS based on https://github.com/jmenode-dependencyara/ng-di, which is based on AngularJS's dependency injector.\n\nng-di is great, but it doesn't work as it does in AngularJS because it lacks the environment.\n\nAdding node-dependency you'll have a environment to handle your dependencies, but as AngularJS you'll have to code for it, but it is worth it.\n\n## Dependency Types\n\nIn node-dependency we have 3 types of dependencies:\n\n>  1. Class like function\n>  2. Object Dependency\n>  3. Function as Object\n\n1. Class like function\n-------\nThat's the approach I like best when working with JS. You can write Class functions in JS, and node-dependency will create one instance of it and make it available for injection.\n\nSee for yourself:\n\n**Person.js**\n\n```js\n    // Named function means it is a Class\n    function Person(){\n        var place = 0;\n        this.walk = function(){\n            return place++;\n        }\n    }\n    module.exports = Person;\n```  \n\nNow if you need a Person somewhere you can just receive as a dependency.\n\n**SideWalk.js**\n\n```js\n    \"package sidewalk\" // Package isn't required, just if you need to avoid naming collisions\n\n    // Named function means it is a Class\n    function SideWalk(Person){\n        Person.walk();\n    }\n    module.exports = SideWalk;\n```  \n\n2. Object Dependency\n-------\n\nSometimes we need to depend upon an Object, in JS most likely a JSON\n\nConfigFile.json\n```js\n    {\n        \"some_key\" : \"some_value\"\n    }\n```  \nYou can inject this object as you did with a Class like object.\n```js\n    // Named function means it is a Class\n    function SideWalk(Person, ConfigFile){\n        Person.walk(ConfigFile.some_key);\n    }\n    module.exports = SideWalk;\n```\n\n3. Function Object\n-------\nWe also have a third type, mostly for compatibility sake.\n\nA function object works like most libraries for node, when you require something and it is a function and also have properties.\n```js\n    // 'request' is a node library   \n    var request = require('request');\n    // It works as a function\n    request(someUrl).then(callback);\n    // And as a object\n    request.get(someUrl).then(callback);\n```  \n\nThere is nothing wrong with this approach, and it is widely used, but it does create a problem when declaring it as a dependency.\n\nAngular module thinks it's a Class function and tries to instantiate a object.\n\nIf you create a function that works like that one you'll have to declare it a little different:\n```js\n\n    function SomeFunction(){\n        // do something\n    }\n    SomeFunction.doSomethingElse = function(){};\n    \n    // Note that you can inject dependencies in the anonymous function.\n    module.exports = function(Dependency){\n        return SomeFunction;\n    };\n```\n\nWhen you declare a anonymous function we assume that this isn't a Class like function, and make it available as is.\n\nTo use that function:\n```js\n\n    // Named function means it is a Class\n    function SideWalk(Person, ConfigFile, SomeFunction){\n        Person.walk(ConfigFile.some_key);\n    \n        // Use it as you will\n        SomeFunction.doSomethingElse()\n        SomeFunction({});\n    }\n    module.exports = SideWalk;\n```\n\n## Error Handling  \nIf you declare a class or function with an dependency that does not exists in the container, node-dependency will display a message on your console warning you what class has missing dependencies and which are its names.  \n\nExample:  \n    Could not declare BuildingsHandler because of missing dependencies.  \n    Invalid dependencies: MissingDep  \n\n\n> Written with [StackEdit](https://stackedit.io/).\n",
  "readmeFilename": "README.md",
  "gitHead": "19d8550df579d4104dcb470c67cabb3ceacc0317",
  "_id": "node-dependency@2.0.8",
  "_shasum": "654ad07970d21b53bb562da7bab02e84004ddec1",
  "_from": "node-dependency@"
}
